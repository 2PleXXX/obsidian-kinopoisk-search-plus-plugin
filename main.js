/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianKinopoiskPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// Views/search_modal.ts
var import_obsidian3 = require("obsidian");

// APIProvider/provider.ts
var import_obsidian2 = require("obsidian");

// i18n.ts
var ru = {
  common: {
    ok: "\u041E\u041A",
    cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
    save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
    loading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430...",
    error: "\u041E\u0448\u0438\u0431\u043A\u0430",
    success: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E"
  },
  modals: {
    searchTitle: "\u{1F37F} \u041F\u043E\u0438\u0441\u043A \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430",
    searchPlaceholder: "\u041F\u043E\u0438\u0441\u043A \u043F\u043E \u043A\u043B\u044E\u0447\u0435\u0432\u043E\u043C\u0443 \u0441\u043B\u043E\u0432\u0443",
    searchButton: "\u041D\u0430\u0439\u0442\u0438",
    searching: "\u041F\u043E\u0438\u0441\u043A...",
    enterMovieName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
    needApiToken: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
    loadingMovieInfo: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442\u0441\u044F \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0444\u0438\u043B\u044C\u043C\u0435...",
    preparingImages: "\u041F\u043E\u0434\u0433\u043E\u0442\u043E\u0432\u043A\u0430 \u043A \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439...",
    movieInfoLoaded: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0444\u0438\u043B\u044C\u043C\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u0430!",
    errorMovieData: "\u041E\u0448\u0438\u0431\u043A\u0430: \u043D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0438\u043B\u044C\u043C\u0430",
    errorUnexpected: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430",
    errorGettingDetails: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438 \u043E \u0444\u0438\u043B\u044C\u043C\u0435",
    // Новые строки из suggest_modal.ts
    posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
    posterTooltipGeoblock: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0433\u0435\u043E\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u043A\u0430)",
    posterTooltipMissing: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442",
    posterTooltipEmptyLink: "\u041F\u0443\u0441\u0442\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440",
    posterTooltipInvalidLink: "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440"
  },
  suggesters: {
    fileListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u0444\u0430\u0439\u043B\u043E\u0432:",
    folderListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u043F\u0430\u043F\u043E\u043A:"
  },
  validation: {
    invalidApiToken: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
    invalidSearchQuery: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441",
    invalidMovieId: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
    invalidPaginationParams: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u044B \u043F\u0430\u0433\u0438\u043D\u0430\u0446\u0438\u0438"
  },
  provider: {
    tokenRequired: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
    enterMovieTitle: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
    nothingFound: '\u041F\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u0443 "{query}" \u043D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E.',
    invalidMovieId: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
    tokenRequiredForMovie: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
    movieInfoError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E \u0444\u0438\u043B\u044C\u043C\u0435",
    tryChangeQuery: "\u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441."
  },
  errorHandler: {
    badRequest: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0432\u0432\u0435\u0434\u0435\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435.",
    unauthorized: "\u041D\u0435\u0430\u0432\u0442\u043E\u0440\u0438\u0437\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0434\u043E\u0441\u0442\u0443\u043F. \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C, \u0447\u0442\u043E API \u0442\u043E\u043A\u0435\u043D \u0443\u043A\u0430\u0437\u0430\u043D \u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D.",
    forbidden: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D \u0441\u0443\u0442\u043E\u0447\u043D\u044B\u0439 \u043B\u0438\u043C\u0438\u0442. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
    notFound: "\u0414\u0430\u043D\u043D\u044B\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441.",
    tooManyRequests: "\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u043D\u043E\u0433\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u043E\u0432. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u043D\u0435\u043C\u043D\u043E\u0433\u043E \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
    internalServerError: "\u0412\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044F\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
    badGateway: "\u0421\u0435\u0440\u0432\u0435\u0440 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (502 Bad Gateway).",
    serviceUnavailable: "\u0421\u0435\u0440\u0432\u0438\u0441 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443 \u043F\u043E\u0437\u0436\u0435.",
    gatewayTimeout: "\u0421\u0435\u0440\u0432\u0435\u0440 \u043D\u0435 \u043E\u0442\u0432\u0435\u0447\u0430\u0435\u0442. \u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F (504 Gateway Timeout).",
    networkError: "\u041F\u0440\u043E\u0431\u043B\u0435\u043C\u044B \u0441 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435\u043C \u043A \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442\u0443. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435.",
    unknownStatusError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435 \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443 (\u043A\u043E\u0434 {status}). \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
    unexpectedError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435."
  },
  images: {
    poster: "\u043F\u043E\u0441\u0442\u0435\u0440\u0430",
    cover: "\u043E\u0431\u043B\u043E\u0436\u043A\u0438",
    logo: "\u043B\u043E\u0433\u043E\u0442\u0438\u043F\u0430",
    noImagesToDownload: "\u041D\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u0434\u043B\u044F \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044F",
    downloading: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435",
    downloadingPoster: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E\u0441\u0442\u0435\u0440\u0430...",
    downloadingCover: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043E\u0431\u043B\u043E\u0436\u043A\u0438...",
    downloadingLogo: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u0430...",
    completed: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E!",
    completedAllDownloaded: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0412\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0441\u043A\u0430\u0447\u0430\u043D\u044B",
    completedAlreadyLocal: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0443\u0436\u0435 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u044B\u0435",
    completedWithErrors: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0423\u0441\u043F\u0435\u0448\u043D\u043E: {successful}, \u043D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C: {failed}",
    invalidUrl: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 URL: {url}. \u041E\u0436\u0438\u0434\u0430\u043B\u0441\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 HTTP/HTTPS URL.",
    imageNotFound: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E (404): {url}",
    accessForbidden: "\u0414\u043E\u0441\u0442\u0443\u043F \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D (403): {url}",
    serverError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 ({status}): {url}",
    httpError: "HTTP {status}: {url}",
    downloadFailed: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435: {url}",
    timeout: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u043F\u043E\u0441\u043B\u0435 {timeout}\u043C\u0441",
    downloadedWithErrors: "\u0421\u043A\u0430\u0447\u0430\u043D\u043E: {successful}/{total} \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439. \u041D\u0435\u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435.",
    imagesUnavailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044E\u0442\u0441\u044F \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0441\u0441\u044B\u043B\u043A\u0438.",
    processingError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
    posterUnavailable: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
    coverUnavailable: "\u041E\u0431\u043B\u043E\u0436\u043A\u0430 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
    logoUnavailable: "\u041B\u043E\u0433\u043E\u0442\u0438\u043F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
    downloadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C"
  },
  utils: {
    unknownMovie: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0439 \u0444\u0438\u043B\u044C\u043C",
    copyPrefix: "\u041A\u043E\u043F\u0438\u044F",
    templateNotFound: "\u0428\u0430\u0431\u043B\u043E\u043D \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D",
    templateReadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u043E\u0447\u0438\u0442\u0430\u0442\u044C \u0444\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430"
  },
  settings: {
    apiToken: "API \u0422\u043E\u043A\u0435\u043D",
    apiTokenDesc: "\u0412\u0430\u043C \u043D\u0443\u0436\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u043F\u043B\u0430\u0433\u0438\u043D\u0430. \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0431\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u044B\u0439 \u043F\u043B\u0430\u043D \u0438 \u0441\u043B\u0435\u0434\u0443\u0439\u0442\u0435 \u0438\u043D\u0441\u0442\u0440\u0443\u043A\u0446\u0438\u044F\u043C.",
    getApiToken: "\u041F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0422\u043E\u043A\u0435\u043D",
    checkToken: "\u041F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\u044C \u0442\u043E\u043A\u0435\u043D",
    checking: "\u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C...",
    tokenValid: "\u2705 \u0422\u043E\u043A\u0435\u043D \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D!",
    tokenInvalid: "\u274C \u0422\u043E\u043A\u0435\u043D \u043D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0442\u043E\u043A\u0435\u043D\u0430.",
    tokenError: "\u274C \u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0435 \u0442\u043E\u043A\u0435\u043D\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
    enterToken: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438",
    imagesHeading: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
    saveImagesLocally: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E",
    saveImagesLocallyDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u0443\u044E \u043F\u0430\u043F\u043A\u0443 \u0432\u043C\u0435\u0441\u0442\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0432\u0435\u0431-\u0441\u0441\u044B\u043B\u043E\u043A.",
    imagesFolder: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
    imagesFolderDesc: "\u041F\u0430\u043F\u043A\u0430, \u0433\u0434\u0435 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B \u0441\u043A\u0430\u0447\u0430\u043D\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F.",
    imagesFolderPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: attachments/kinopoisk",
    savePosterImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B",
    savePosterImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
    saveCoverImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0438",
    saveCoverImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0438/\u0431\u044D\u043A\u0434\u0440\u043E\u043F\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
    saveLogoImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u044B",
    saveLogoImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
    moviesHeading: "\u0424\u0438\u043B\u044C\u043C\u044B",
    movieFileName: "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0444\u0438\u043B\u044C\u043C\u0430",
    movieFileNameDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u043C\u043E\u0432.",
    movieFileNamePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}} ({{year}})",
    movieFileLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u0444\u0438\u043B\u044C\u043C\u043E\u0432",
    movieFileLocationDesc: "\u041D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0444\u0438\u043B\u044C\u043C\u0430\u0445 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0437\u043C\u0435\u0449\u0435\u043D\u044B \u0437\u0434\u0435\u0441\u044C.",
    movieFileLocationPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0430\u043F\u043A\u04301/\u043F\u0430\u043F\u043A\u04302",
    movieTemplateFile: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u043C\u043E\u0432",
    movieTemplateFileDesc: "\u0424\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D\u044B.",
    movieTemplateFilePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/template-file",
    exampleTemplate: "\u041F\u0440\u0438\u043C\u0435\u0440 \u0448\u0430\u0431\u043B\u043E\u043D\u0430",
    seriesHeading: "\u0421\u0435\u0440\u0438\u0430\u043B\u044B",
    seriesFileName: "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0441\u0435\u0440\u0438\u0430\u043B\u0430",
    seriesFileNameDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
    seriesFileNamePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}} ({{year}})",
    seriesFileLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432",
    seriesFileLocationDesc: "\u041D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0441\u0435\u0440\u0438\u0430\u043B\u0430\u0445 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0437\u043C\u0435\u0449\u0435\u043D\u044B \u0437\u0434\u0435\u0441\u044C.",
    seriesFileLocationPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0430\u043F\u043A\u04301/\u043F\u0430\u043F\u043A\u04302",
    seriesTemplateFile: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432",
    seriesTemplateFileDesc: "\u0424\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D\u044B.",
    seriesTemplateFilePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/template-file",
    languageHeading: "\u042F\u0437\u044B\u043A",
    language: "\u042F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430",
    languageDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430."
  }
};
var en = {
  common: {
    ok: "OK",
    cancel: "Cancel",
    save: "Save",
    loading: "Loading...",
    error: "Error",
    success: "Success"
  },
  modals: {
    searchTitle: "\u{1F37F} Search movie or TV show",
    searchPlaceholder: "Search by keyword",
    searchButton: "Search",
    searching: "Searching...",
    enterMovieName: "Enter movie or TV show name to search",
    needApiToken: "API token must be specified in plugin settings",
    loadingMovieInfo: "Loading movie information...",
    preparingImages: "Preparing to download images...",
    movieInfoLoaded: "Movie information loaded!",
    errorMovieData: "Error: invalid movie data",
    errorUnexpected: "An unexpected error occurred",
    errorGettingDetails: "An unexpected error occurred while getting movie information",
    // Новые строки из suggest_modal.ts
    posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
    posterTooltipGeoblock: "Poster unavailable (possibly geo-blocked)",
    posterTooltipMissing: "Poster missing",
    posterTooltipEmptyLink: "Empty poster link",
    posterTooltipInvalidLink: "Invalid poster link"
  },
  suggesters: {
    fileListError: "Error getting file list:",
    folderListError: "Error getting folder list:"
  },
  validation: {
    invalidApiToken: "Invalid API token",
    invalidSearchQuery: "Invalid search query",
    invalidMovieId: "Invalid movie ID",
    invalidPaginationParams: "Invalid pagination parameters"
  },
  provider: {
    tokenRequired: "Valid API token must be specified in plugin settings",
    enterMovieTitle: "Enter movie or TV show title to search",
    nothingFound: 'Nothing found for query "{query}".',
    invalidMovieId: "Invalid movie ID",
    tokenRequiredForMovie: "Valid API token must be specified",
    movieInfoError: "Failed to get movie information",
    tryChangeQuery: "Try changing the search query."
  },
  errorHandler: {
    badRequest: "Bad request. Please check the entered data.",
    unauthorized: "Unauthorized access. Make sure the API token is specified and valid.",
    forbidden: "Daily limit exceeded. Please wait and try again.",
    notFound: "Data not found. Try changing the search query.",
    tooManyRequests: "Too many requests. Please wait a bit and try again.",
    internalServerError: "Kinopoisk server internal error. Try again later.",
    badGateway: "Kinopoisk server temporarily unavailable (502 Bad Gateway).",
    serviceUnavailable: "Service temporarily unavailable. Try again later.",
    gatewayTimeout: "Server not responding. Timeout exceeded (504 Gateway Timeout).",
    networkError: "Internet connection problems. Check your connection.",
    unknownStatusError: "An error occurred when requesting the server (code {status}). Try again later.",
    unexpectedError: "An unexpected error occurred during the request. Try again later."
  },
  images: {
    poster: "poster",
    cover: "cover",
    logo: "logo",
    noImagesToDownload: "No images to download",
    downloading: "Downloading",
    downloadingPoster: "Downloading poster...",
    downloadingCover: "Downloading cover...",
    downloadingLogo: "Downloading logo...",
    completed: "Completed!",
    completedAllDownloaded: "Completed! All images downloaded",
    completedAlreadyLocal: "Completed! Images are already local",
    completedWithErrors: "Completed! Successful: {successful}, failed: {failed}",
    invalidUrl: "Invalid URL format: {url}. Expected valid HTTP/HTTPS URL.",
    imageNotFound: "Image not found (404): {url}",
    accessForbidden: "Access forbidden (403): {url}",
    serverError: "Server error ({status}): {url}",
    httpError: "HTTP {status}: {url}",
    downloadFailed: "Failed to download image: {url}",
    timeout: "Timeout after {timeout}ms",
    downloadedWithErrors: "Downloaded: {successful}/{total} images. Some are unavailable in your region.",
    imagesUnavailable: "Images are unavailable in your region. Using original links.",
    processingError: "Error processing images",
    posterUnavailable: "Poster unavailable (possibly blocked in your region)",
    coverUnavailable: "Cover unavailable (possibly blocked in your region)",
    logoUnavailable: "Logo unavailable (possibly blocked in your region)",
    downloadError: "Failed to download"
  },
  utils: {
    unknownMovie: "Unknown Movie",
    copyPrefix: "Copy",
    templateNotFound: "Template not found",
    templateReadError: "Failed to read template file"
  },
  settings: {
    apiToken: "API Token",
    apiTokenDesc: "You need to get API token to use this plugin. Choose free plan and follow steps.",
    getApiToken: "Get API Token",
    checkToken: "Check Token",
    checking: "Checking...",
    tokenValid: "\u2705 Token is valid!",
    tokenInvalid: "\u274C Token is invalid. Please check your token.",
    tokenError: "\u274C Error checking token. Please try again later.",
    enterToken: "Enter API token to check",
    imagesHeading: "Images",
    saveImagesLocally: "Save images locally",
    saveImagesLocallyDesc: "Download and save images to local folder instead of using web URLs.",
    imagesFolder: "Images folder",
    imagesFolderDesc: "Folder where downloaded images will be saved.",
    imagesFolderPlaceholder: "Example: attachments/kinopoisk",
    savePosterImage: "Save poster images",
    savePosterImageDesc: "Download and save movie/series poster images.",
    saveCoverImage: "Save cover/backdrop images",
    saveCoverImageDesc: "Download and save movie/series cover/backdrop images.",
    saveLogoImage: "Save logo images",
    saveLogoImageDesc: "Download and save movie/series logo images.",
    moviesHeading: "Movies",
    movieFileName: "Movie file name",
    movieFileNameDesc: "Enter the movie file name format.",
    movieFileNamePlaceholder: "Example: {{nameForFile}} ({{year}})",
    movieFileLocation: "Movie file location",
    movieFileLocationDesc: "New movie notes will be placed here.",
    movieFileLocationPlaceholder: "Example: folder1/folder2",
    movieTemplateFile: "Movie template file",
    movieTemplateFileDesc: "Files will be available as templates.",
    movieTemplateFilePlaceholder: "Example: templates/template-file",
    exampleTemplate: "Example Template",
    seriesHeading: "TV series",
    seriesFileName: "TV series file name",
    seriesFileNameDesc: "Enter the TV series file name format.",
    seriesFileNamePlaceholder: "Example: {{nameForFile}} ({{year}})",
    seriesFileLocation: "TV series file location",
    seriesFileLocationDesc: "New TV series notes will be placed here.",
    seriesFileLocationPlaceholder: "Example: folder1/folder2",
    seriesTemplateFile: "TV series template file",
    seriesTemplateFileDesc: "Files will be available as templates.",
    seriesTemplateFilePlaceholder: "Example: templates/template-file",
    languageHeading: "Language",
    language: "Interface language",
    languageDesc: "Select the plugin interface language."
  }
};
var translations = {
  ru,
  en
};
var currentLanguage = "en";
function initializeLanguage(userPreference) {
  var _a;
  if (userPreference) {
    currentLanguage = userPreference;
    return;
  }
  const systemLang = navigator.language || ((_a = navigator.languages) == null ? void 0 : _a[0]);
  if (systemLang == null ? void 0 : systemLang.startsWith("ru")) {
    currentLanguage = "ru";
  } else {
    currentLanguage = "en";
  }
}
function setLanguage(language) {
  currentLanguage = language;
}
function getSupportedLanguages() {
  return [
    { code: "ru", name: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
    { code: "en", name: "English" }
  ];
}
function t(key) {
  const keys = key.split(".");
  let value = translations[currentLanguage];
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      console.warn(`Translation key not found: ${key}`);
      return key;
    }
  }
  return typeof value === "string" ? value : key;
}
function tWithParams(key, params) {
  let translation = t(key);
  for (const [paramKey, paramValue] of Object.entries(params)) {
    translation = translation.replace(
      new RegExp(`\\{${paramKey}\\}`, "g"),
      String(paramValue)
    );
  }
  return translation;
}

// APIProvider/ErrorHandler.ts
var NETWORK_ERROR_PATTERNS = [
  "net::",
  "NetworkError",
  "Failed to fetch",
  "ENOTFOUND",
  "ECONNREFUSED",
  "ETIMEDOUT"
];
var ErrorHandler = class {
  /**
   * Получает сообщение об ошибке для HTTP статуса
   */
  getHttpStatusMessage(status) {
    const statusMessages = {
      400: t("errorHandler.badRequest"),
      401: t("errorHandler.unauthorized"),
      403: t("errorHandler.forbidden"),
      404: t("errorHandler.notFound"),
      429: t("errorHandler.tooManyRequests"),
      500: t("errorHandler.internalServerError"),
      502: t("errorHandler.badGateway"),
      503: t("errorHandler.serviceUnavailable"),
      504: t("errorHandler.gatewayTimeout")
    };
    return statusMessages[status] || "";
  }
  /**
   * Обрабатывает ошибки от API и создает понятные сообщения
   */
  handleApiError(error) {
    const errorDetails = this.extractErrorDetails(error);
    if (errorDetails.isNetworkError) {
      return new Error(t("errorHandler.networkError"));
    }
    const knownMessage = this.getHttpStatusMessage(errorDetails.status);
    if (knownMessage) {
      return new Error(knownMessage);
    }
    if (errorDetails.status > 0) {
      return new Error(
        tWithParams("errorHandler.unknownStatusError", {
          status: errorDetails.status.toString()
        })
      );
    }
    return new Error(t("errorHandler.unexpectedError"));
  }
  /**
   * Извлекает детали ошибки из различных форматов
   */
  extractErrorDetails(error) {
    const details = {
      status: 0,
      message: "",
      isNetworkError: false,
      originalError: error
    };
    if (this.isNetworkError(error)) {
      details.isNetworkError = true;
      return details;
    }
    details.status = this.extractStatusCode(error);
    return details;
  }
  /**
   * Проверяет, является ли ошибка сетевой
   */
  isNetworkError(error) {
    if (!(error instanceof Error)) {
      return false;
    }
    return NETWORK_ERROR_PATTERNS.some(
      (pattern) => error.message.includes(pattern)
    );
  }
  /**
   * Извлекает HTTP статус код из объекта ошибки
   */
  extractStatusCode(error) {
    if (!error || typeof error !== "object") {
      return 0;
    }
    if ("status" in error && typeof error.status === "number") {
      return error.status;
    }
    if ("response" in error && error.response && typeof error.response === "object" && "status" in error.response && typeof error.response.status === "number") {
      return error.response.status;
    }
    if ("statusCode" in error && typeof error.statusCode === "number") {
      return error.statusCode;
    }
    return 0;
  }
  /**
   * Логирует ошибку
   */
  logError(context, error) {
    console.error(`[${context}] Error:`, error);
  }
};

// Utils/utils.ts
var import_obsidian = require("obsidian");
function capitalizeFirstLetter(input) {
  if (!input || input.length === 0) {
    return input || "";
  }
  return input.charAt(0).toUpperCase() + input.slice(1);
}
function replaceIllegalFileNameCharactersInString(text) {
  if (!text) {
    return "";
  }
  return text.replace(/[\\/:*?"<>|]/g, "");
}
function getPlainValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = value[0];
      if (typeof firstValue === "string") {
        return firstValue.replace(/^"(.*)"$/, "$1");
      }
      return firstValue != null ? firstValue : "";
    }
    return value.filter((item) => item != null).map((item) => {
      if (typeof item === "string") {
        return item.replace(/^"(.*)"$/, "$1");
      }
      return String(item);
    }).join(", ");
  }
  if (typeof value === "number") {
    return value;
  }
  return String(value || "");
}
function getQuotedValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = String(value[0] || "");
      if (firstValue.startsWith("![[") || firstValue.startsWith("![](")) {
        if (!firstValue.startsWith('"') && !firstValue.endsWith('"')) {
          return `"${firstValue}"`;
        }
      }
      if (firstValue.startsWith('"') && firstValue.endsWith('"')) {
        const innerText = firstValue.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return firstValue;
    }
    return value.filter((item) => item != null).map((item) => {
      const itemStr = String(item);
      if (itemStr.startsWith("![[") || itemStr.startsWith("![](")) {
        if (!itemStr.startsWith('"') && !itemStr.endsWith('"')) {
          return `"${itemStr}"`;
        }
      }
      if (itemStr.startsWith('"') && itemStr.endsWith('"')) {
        const innerText = itemStr.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return itemStr;
    }).join(", ");
  }
  const stringValue = String(value || "");
  if (stringValue.startsWith('"') && stringValue.endsWith('"')) {
    const innerText = stringValue.slice(1, -1);
    const escapedInnerText = innerText.replace(/"/g, '\\"');
    return `"${escapedInnerText}"`;
  }
  return stringValue;
}
function replaceVariableSyntax(movieShow, text) {
  if (!(text == null ? void 0 : text.trim())) {
    return "";
  }
  try {
    const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    const match = text.match(frontmatterRegex);
    if (match) {
      const [, frontmatter, body] = match;
      const processedFrontmatter = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const quotedValue = getQuotedValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              quotedValue
            );
          } catch (error) {
            console.error(
              `Error processing frontmatter variable ${key}:`,
              error
            );
            return result2;
          }
        },
        frontmatter
      );
      const processedBody = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const plainValue = getPlainValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              String(plainValue)
            );
          } catch (error) {
            console.error(
              `Error processing body variable ${key}:`,
              error
            );
            return result2;
          }
        },
        body
      );
      const result = `---
${processedFrontmatter}
---
${processedBody}`;
      return result.replace(/{{\w+}}/gi, "").trim();
    } else {
      const entries = Object.entries(movieShow);
      return entries.reduce((result, [key, val = ""]) => {
        try {
          const plainValue = getPlainValueFromArray(val);
          return result.replace(
            new RegExp(`{{${key}}}`, "ig"),
            String(plainValue)
          );
        } catch (error) {
          console.error(
            `Error processing variable ${key}:`,
            error
          );
          return result;
        }
      }, text).replace(/{{\w+}}/gi, "").trim();
    }
  } catch (error) {
    console.error("Error in replaceVariableSyntax:", error);
    return text;
  }
}
async function makeFileName(app, movieShow, fileNameFormat, folderPath) {
  try {
    let baseName;
    if (fileNameFormat) {
      baseName = replaceVariableSyntax(movieShow, fileNameFormat);
    } else {
      baseName = `${movieShow.nameForFile || t("utils.unknownMovie")} (${movieShow.year || t("utils.unknownMovie")})`;
    }
    const cleanedBaseName = replaceIllegalFileNameCharactersInString(baseName);
    if (!cleanedBaseName.trim()) {
      return `${t("utils.unknownMovie")}.md`;
    }
    const fileName = cleanedBaseName + ".md";
    const { vault } = app;
    const fullPath = folderPath ? `${folderPath}/${fileName}` : fileName;
    const normalizedPath = (0, import_obsidian.normalizePath)(fullPath);
    if (!vault.getAbstractFileByPath(normalizedPath)) {
      return fileName;
    }
    let copyNumber = 1;
    let copyFileName;
    let copyFullPath;
    do {
      copyFileName = `${cleanedBaseName} (${t(
        "utils.copyPrefix"
      )}[${copyNumber}]).md`;
      copyFullPath = folderPath ? `${folderPath}/${copyFileName}` : copyFileName;
      copyNumber++;
    } while (vault.getAbstractFileByPath((0, import_obsidian.normalizePath)(copyFullPath)));
    return copyFileName;
  } catch (error) {
    console.error("Error creating file name:", error);
    return `${t("utils.unknownMovie")}.md`;
  }
}
async function getTemplateContents(app, templatePath) {
  if (!templatePath || templatePath === "/") {
    return "";
  }
  try {
    const { metadataCache, vault } = app;
    const normalizedTemplatePath = (0, import_obsidian.normalizePath)(templatePath);
    const templateFile = metadataCache.getFirstLinkpathDest(
      normalizedTemplatePath,
      ""
    );
    if (!templateFile) {
      console.warn(
        `${t("utils.templateNotFound")}: ${normalizedTemplatePath}`
      );
      return "";
    }
    return await vault.cachedRead(templateFile);
  } catch (error) {
    console.error(`Failed to read the template '${templatePath}':`, error);
    new import_obsidian.Notice(t("utils.templateReadError"));
    return "";
  }
}

// APIProvider/DataFormatter.ts
var MAX_ARRAY_ITEMS = 15;
var MAX_FACTS_COUNT = 5;
var TYPE_TRANSLATIONS = {
  "animated-series": "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u043E\u043D\u043D\u044B\u0439 \u0441\u0435\u0440\u0438\u0430\u043B",
  anime: "\u0410\u043D\u0438\u043C\u0435",
  cartoon: "\u041C\u0443\u043B\u044C\u0442\u0444\u0438\u043B\u044C\u043C",
  movie: "\u0424\u0438\u043B\u044C\u043C",
  "tv-series": "\u0421\u0435\u0440\u0438\u0430\u043B"
};
var HTML_ENTITIES = {
  "&laquo;": "\xAB",
  "&raquo;": "\xBB",
  "&ldquo;": '"',
  "&rdquo;": '"',
  "&lsquo;": "'",
  "&rsquo;": "'",
  "&quot;": '"',
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&nbsp;": " ",
  "&ndash;": "\u2013",
  "&mdash;": "\u2014",
  "&hellip;": "\u2026"
};
var DataFormatter = class {
  /**
   * Основной метод преобразования данных API в формат MovieShow
   */
  createMovieShowFrom(fullInfo) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M;
    const seasonsData = this.calculateSeasonsData(fullInfo.seasonsInfo);
    const people = this.extractPeople(fullInfo.persons || []);
    const companies = this.extractCompanies(fullInfo);
    const facts = this.processFacts(fullInfo.facts || []);
    const names = this.processNames(fullInfo);
    const firstReleaseYear = (_a = fullInfo.releaseYears) == null ? void 0 : _a[0];
    const item = {
      // Основная информация
      id: fullInfo.id,
      name: this.formatArray([fullInfo.name], "short" /* SHORT_VALUE */),
      alternativeName: this.formatArray(
        [fullInfo.alternativeName || ""],
        "short" /* SHORT_VALUE */
      ),
      year: fullInfo.year,
      description: this.formatArray(
        [fullInfo.description || ""],
        "long" /* LONG_TEXT */
      ),
      shortDescription: this.formatArray(
        [fullInfo.shortDescription || ""],
        "long" /* LONG_TEXT */
      ),
      // Дополнительные свойства для имен файлов
      nameForFile: this.cleanTextForMetadata(fullInfo.name),
      alternativeNameForFile: this.cleanTextForMetadata(
        fullInfo.alternativeName || ""
      ),
      enNameForFile: this.cleanTextForMetadata(fullInfo.enName || ""),
      // Изображения
      posterUrl: this.formatArray(
        [((_b = fullInfo.poster) == null ? void 0 : _b.url) || ""],
        "url" /* URL */
      ),
      coverUrl: this.formatArray(
        [((_c = fullInfo.backdrop) == null ? void 0 : _c.url) || ""],
        "url" /* URL */
      ),
      logoUrl: this.formatArray(
        [((_d = fullInfo.logo) == null ? void 0 : _d.url) || ""],
        "url" /* URL */
      ),
      // Готовые ссылки на изображения для Obsidian
      posterImageLink: this.createImageLink(((_e = fullInfo.poster) == null ? void 0 : _e.url) || ""),
      coverImageLink: this.createImageLink(((_f = fullInfo.backdrop) == null ? void 0 : _f.url) || ""),
      logoImageLink: this.createImageLink(((_g = fullInfo.logo) == null ? void 0 : _g.url) || ""),
      // Классификация
      genres: this.formatArray(
        fullInfo.genres.map((g) => capitalizeFirstLetter(g.name)),
        "short" /* SHORT_VALUE */
      ),
      genresLinks: this.formatArray(
        fullInfo.genres.map((g) => capitalizeFirstLetter(g.name)),
        "link" /* LINK */
      ),
      countries: this.formatArray(
        fullInfo.countries.map((c) => c.name),
        "short" /* SHORT_VALUE */
      ),
      countriesLinks: this.formatArray(
        fullInfo.countries.map((c) => c.name),
        "link" /* LINK */
      ),
      type: this.formatArray(
        [this.translateType(fullInfo.type || "")],
        "short" /* SHORT_VALUE */
      ),
      subType: this.formatArray(
        [fullInfo.subType || ""],
        "short" /* SHORT_VALUE */
      ),
      // Люди
      director: this.formatArray(
        people.directors,
        "short" /* SHORT_VALUE */
      ),
      directorsLinks: this.formatArray(people.directors, "link" /* LINK */),
      actors: this.formatArray(people.actors, "short" /* SHORT_VALUE */),
      actorsLinks: this.formatArray(people.actors, "link" /* LINK */),
      writers: this.formatArray(people.writers, "short" /* SHORT_VALUE */),
      writersLinks: this.formatArray(people.writers, "link" /* LINK */),
      producers: this.formatArray(
        people.producers,
        "short" /* SHORT_VALUE */
      ),
      producersLinks: this.formatArray(people.producers, "link" /* LINK */),
      // Технические характеристики
      movieLength: fullInfo.movieLength || 0,
      isSeries: fullInfo.isSeries,
      seriesLength: fullInfo.seriesLength || 0,
      totalSeriesLength: fullInfo.totalSeriesLength || 0,
      isComplete: (fullInfo.status || "") === "completed",
      seasonsCount: seasonsData.count,
      seriesInSeasonCount: seasonsData.averageEpisodesPerSeason,
      // Рейтинги и голоса
      ratingKp: ((_h = fullInfo.rating) == null ? void 0 : _h.kp) || 0,
      ratingImdb: ((_i = fullInfo.rating) == null ? void 0 : _i.imdb) || 0,
      ratingFilmCritics: ((_j = fullInfo.rating) == null ? void 0 : _j.filmCritics) || 0,
      ratingRussianFilmCritics: ((_k = fullInfo.rating) == null ? void 0 : _k.russianFilmCritics) || 0,
      votesKp: ((_l = fullInfo.votes) == null ? void 0 : _l.kp) || 0,
      votesImdb: ((_m = fullInfo.votes) == null ? void 0 : _m.imdb) || 0,
      votesFilmCritics: ((_n = fullInfo.votes) == null ? void 0 : _n.filmCritics) || 0,
      votesRussianFilmCritics: ((_o = fullInfo.votes) == null ? void 0 : _o.russianFilmCritics) || 0,
      // Внешние идентификаторы и ссылки
      kinopoiskUrl: this.formatArray(
        [`https://www.kinopoisk.ru/film/${fullInfo.id}/`],
        "url" /* URL */
      ),
      imdbId: this.formatArray(
        [((_p = fullInfo.externalId) == null ? void 0 : _p.imdb) || ""],
        "short" /* SHORT_VALUE */
      ),
      tmdbId: ((_q = fullInfo.externalId) == null ? void 0 : _q.tmdb) || 0,
      kpHDId: this.formatArray(
        [((_r = fullInfo.externalId) == null ? void 0 : _r.kpHD) || ""],
        "short" /* SHORT_VALUE */
      ),
      // Дополнительная информация
      slogan: this.formatArray(
        [fullInfo.slogan || ""],
        "long" /* LONG_TEXT */
      ),
      ageRating: fullInfo.ageRating || 0,
      ratingMpaa: this.formatArray(
        [fullInfo.ratingMpaa || ""],
        "short" /* SHORT_VALUE */
      ),
      // Финансы
      budgetValue: ((_s = fullInfo.budget) == null ? void 0 : _s.value) || 0,
      budgetCurrency: this.formatArray(
        [((_t = fullInfo.budget) == null ? void 0 : _t.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      feesWorldValue: ((_v = (_u = fullInfo.fees) == null ? void 0 : _u.world) == null ? void 0 : _v.value) || 0,
      feesWorldCurrency: this.formatArray(
        [((_x = (_w = fullInfo.fees) == null ? void 0 : _w.world) == null ? void 0 : _x.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      feesRussiaValue: ((_z = (_y = fullInfo.fees) == null ? void 0 : _y.russia) == null ? void 0 : _z.value) || 0,
      feesRussiaCurrency: this.formatArray(
        [((_B = (_A = fullInfo.fees) == null ? void 0 : _A.russia) == null ? void 0 : _B.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      feesUsaValue: ((_D = (_C = fullInfo.fees) == null ? void 0 : _C.usa) == null ? void 0 : _D.value) || 0,
      feesUsaCurrency: this.formatArray(
        [((_F = (_E = fullInfo.fees) == null ? void 0 : _E.usa) == null ? void 0 : _F.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      // Даты премьер
      premiereWorld: this.formatArray(
        [this.formatDate((_G = fullInfo.premiere) == null ? void 0 : _G.world)],
        "short" /* SHORT_VALUE */
      ),
      premiereRussia: this.formatArray(
        [this.formatDate((_H = fullInfo.premiere) == null ? void 0 : _H.russia)],
        "short" /* SHORT_VALUE */
      ),
      premiereDigital: this.formatArray(
        [this.formatDate((_I = fullInfo.premiere) == null ? void 0 : _I.digital)],
        "short" /* SHORT_VALUE */
      ),
      premiereCinema: this.formatArray(
        [this.formatDate((_J = fullInfo.premiere) == null ? void 0 : _J.cinema)],
        "short" /* SHORT_VALUE */
      ),
      // Периоды выпуска
      releaseYearsStart: (firstReleaseYear == null ? void 0 : firstReleaseYear.start) || 0,
      releaseYearsEnd: (firstReleaseYear == null ? void 0 : firstReleaseYear.end) || 0,
      // Рейтинги в топах
      top10: fullInfo.top10 || 0,
      top250: fullInfo.top250 || 0,
      // Факты
      facts: this.formatArray(facts, "long" /* LONG_TEXT */),
      // Альтернативные названия
      allNamesString: this.formatArray(
        names.allNames,
        "short" /* SHORT_VALUE */
      ),
      enName: this.formatArray(
        [fullInfo.enName || ""],
        "short" /* SHORT_VALUE */
      ),
      // Сети и компании
      networks: this.formatArray(
        companies.networks,
        "short" /* SHORT_VALUE */
      ),
      networksLinks: this.formatArray(
        companies.networks,
        "link" /* LINK */
      ),
      productionCompanies: this.formatArray(
        companies.productionCompanies,
        "short" /* SHORT_VALUE */
      ),
      productionCompaniesLinks: this.formatArray(
        companies.productionCompanies,
        "link" /* LINK */
      ),
      // Дистрибьюторы
      distributor: this.formatArray(
        [((_K = fullInfo.distributors) == null ? void 0 : _K.distributor) || ""],
        "short" /* SHORT_VALUE */
      ),
      distributorRelease: this.formatArray(
        [
          this.formatDate(
            (_L = fullInfo.distributors) == null ? void 0 : _L.distributorRelease
          ) || ((_M = fullInfo.distributors) == null ? void 0 : _M.distributorRelease) || ""
        ],
        "short" /* SHORT_VALUE */
      ),
      // Связанные фильмы/сериалы
      sequelsAndPrequels: this.formatArray(
        companies.sequelsAndPrequels,
        "short" /* SHORT_VALUE */
      ),
      sequelsAndPrequelsLinks: this.formatArray(
        companies.sequelsAndPrequels,
        "link" /* LINK */
      )
    };
    return item;
  }
  /**
   * Универсальное форматирование массивов в зависимости от типа
   */
  formatArray(items, formatType, maxItems = MAX_ARRAY_ITEMS) {
    const filteredItems = items.filter((item) => item && item.trim() !== "").slice(0, maxItems);
    switch (formatType) {
      case "short" /* SHORT_VALUE */:
        return filteredItems.map(
          (item) => this.cleanTextForMetadata(item)
        );
      case "long" /* LONG_TEXT */:
        return filteredItems.map((item) => {
          const cleanedItem = item.replace(/\n/g, " ").replace(/\s+/g, " ").trim();
          return `"${cleanedItem}"`;
        });
      case "url" /* URL */:
        return filteredItems.map((item) => item.trim());
      case "link" /* LINK */:
        return filteredItems.map(
          (item) => `"[[${this.cleanTextForMetadata(item)}]]"`
        );
      default:
        return filteredItems;
    }
  }
  /**
   * Вычисляет данные о сезонах
   */
  calculateSeasonsData(seasonsInfo) {
    if (!seasonsInfo || seasonsInfo.length === 0) {
      return { count: 0, averageEpisodesPerSeason: 0 };
    }
    const totalEpisodes = seasonsInfo.reduce(
      (total, season) => total + season.episodesCount,
      0
    );
    const averageEpisodes = Math.ceil(totalEpisodes / seasonsInfo.length);
    return {
      count: seasonsInfo.length,
      averageEpisodesPerSeason: averageEpisodes
    };
  }
  /**
   * Извлекает людей по профессиям
   */
  extractPeople(persons) {
    const result = {
      directors: [],
      actors: [],
      writers: [],
      producers: []
    };
    for (const person of persons) {
      if (!person.name || !person.enProfession) continue;
      switch (person.enProfession) {
        case "director":
          result.directors.push(person.name);
          break;
        case "actor":
          result.actors.push(person.name);
          break;
        case "writer":
          result.writers.push(person.name);
          break;
        case "producer":
          result.producers.push(person.name);
          break;
      }
    }
    return result;
  }
  /**
   * Извлекает компании и связанные фильмы
   */
  extractCompanies(fullInfo) {
    var _a, _b, _c, _d;
    const networks = ((_b = (_a = fullInfo.networks) == null ? void 0 : _a.items) == null ? void 0 : _b.map((network) => network.name).filter((name) => name && name.trim() !== "")) || [];
    const productionCompanies = ((_c = fullInfo.productionCompanies) == null ? void 0 : _c.map((company) => company.name).filter((name) => name && name.trim() !== "")) || [];
    const sequelsAndPrequels = ((_d = fullInfo.sequelsAndPrequels) == null ? void 0 : _d.map((movie) => movie.name).filter((name) => name && name.trim() !== "")) || [];
    return { networks, productionCompanies, sequelsAndPrequels };
  }
  /**
   * Обрабатывает факты (удаляет спойлеры и HTML)
   */
  processFacts(facts) {
    return facts.filter(
      (fact) => !fact.spoiler && fact.value && fact.value.trim() !== ""
    ).slice(0, MAX_FACTS_COUNT).map((fact) => this.stripHtmlTags(fact.value));
  }
  /**
   * Обрабатывает названия
   */
  processNames(fullInfo) {
    var _a;
    const allNames = ((_a = fullInfo.names) == null ? void 0 : _a.map((nameObj) => nameObj.name).filter((name) => name && name.trim() !== "")) || [];
    return { allNames };
  }
  /**
   * Форматирует дату в формат Obsidian (YYYY-MM-DD)
   */
  formatDate(dateString) {
    if (!dateString) return "";
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime()) || date.getFullYear() < 1800 || date.getFullYear() > 2100) {
        return "";
      }
      return date.toISOString().split("T")[0];
    } catch (e) {
      return "";
    }
  }
  /**
   * Очищает текст от символов, которые могут нарушить метаданные
   */
  cleanTextForMetadata(text) {
    if (!text) return "";
    return text.replace(/:/g, "").trim();
  }
  /**
   * Создает ссылку на изображение для Obsidian
   */
  createImageLink(imagePath) {
    if (!imagePath || imagePath.trim() === "") return [];
    if (!imagePath.startsWith("http")) {
      return [`![[${imagePath}]]`];
    }
    return [`![](${imagePath})`];
  }
  /**
   * Переводит типы контента на русский язык
   */
  translateType(type) {
    return TYPE_TRANSLATIONS[type] || type;
  }
  /**
   * Удаляет HTML теги и декодирует HTML сущности
   */
  stripHtmlTags(text) {
    let cleanText = text.replace(/<[^>]*>/g, "");
    for (const [entity, char] of Object.entries(HTML_ENTITIES)) {
      cleanText = cleanText.replace(new RegExp(entity, "g"), char);
    }
    cleanText = cleanText.replace(/&#?\w+;/g, "");
    return cleanText.trim();
  }
};

// APIProvider/ApiValidator.ts
var MIN_QUERY_LENGTH = 1;
var MAX_QUERY_LENGTH = 200;
var MIN_TOKEN_LENGTH = 10;
var MAX_TOKEN_LENGTH = 100;
var MIN_MOVIE_ID = 1;
var MAX_MOVIE_ID = 99999999;
var ApiValidator = class {
  /**
   * Проверяет валидность API токена
   */
  isValidToken(token) {
    if (typeof token !== "string") {
      return false;
    }
    const trimmedToken = token.trim();
    if (!trimmedToken) {
      return false;
    }
    if (trimmedToken.length < MIN_TOKEN_LENGTH || trimmedToken.length > MAX_TOKEN_LENGTH) {
      return false;
    }
    const tokenPattern = /^[A-Za-z0-9\-_]+$/;
    if (!tokenPattern.test(trimmedToken)) {
      return false;
    }
    return true;
  }
  /**
   * Проверяет валидность поискового запроса
   */
  isValidSearchQuery(query) {
    if (typeof query !== "string") {
      return false;
    }
    const trimmedQuery = query.trim();
    if (!trimmedQuery) {
      return false;
    }
    if (trimmedQuery.length < MIN_QUERY_LENGTH || trimmedQuery.length > MAX_QUERY_LENGTH) {
      return false;
    }
    const suspiciousPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+=/i,
      /<%/,
      /%>/
    ];
    if (suspiciousPatterns.some((pattern) => pattern.test(trimmedQuery))) {
      return false;
    }
    return true;
  }
  /**
   * Проверяет валидность ID фильма
   */
  isValidMovieId(id) {
    if (typeof id !== "number") {
      return false;
    }
    if (!Number.isFinite(id)) {
      return false;
    }
    if (id < MIN_MOVIE_ID || id > MAX_MOVIE_ID) {
      return false;
    }
    if (!Number.isInteger(id)) {
      return false;
    }
    return true;
  }
  /**
   * Проверяет валидность параметров пагинации
   */
  isValidPaginationParams(page, limit) {
    if (page !== void 0) {
      if (!Number.isInteger(page) || page < 1 || page > 1e3) {
        return false;
      }
    }
    if (limit !== void 0) {
      if (!Number.isInteger(limit) || limit < 1 || limit > 250) {
        return false;
      }
    }
    return true;
  }
  /**
   * Санитизирует поисковый запрос
   */
  sanitizeQuery(query) {
    return query.trim().replace(/\s+/g, " ").replace(/[<>]/g, "").substring(0, MAX_QUERY_LENGTH);
  }
  /**
   * Санитизирует токен
   */
  sanitizeToken(token) {
    return token.trim().replace(/[^A-Za-z0-9\-_]/g, "").substring(0, MAX_TOKEN_LENGTH);
  }
  /**
   * Проверяет общую валидность конфигурации запроса
   */
  validateRequestConfig(config) {
    const errors = [];
    if (!this.isValidToken(config.token)) {
      errors.push(t("validation.invalidApiToken"));
    }
    if (config.query !== void 0 && !this.isValidSearchQuery(config.query)) {
      errors.push(t("validation.invalidSearchQuery"));
    }
    if (config.movieId !== void 0 && !this.isValidMovieId(config.movieId)) {
      errors.push(t("validation.invalidMovieId"));
    }
    if (!this.isValidPaginationParams(config.page, config.limit)) {
      errors.push(t("validation.invalidPaginationParams"));
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
};

// APIProvider/provider.ts
var API_BASE_URL = "https://api.kinopoisk.dev/v1.4";
var MAX_SEARCH_RESULTS = 50;
var KinopoiskProvider = class {
  constructor() {
    this.errorHandler = new ErrorHandler();
    this.dataFormatter = new DataFormatter();
    this.validator = new ApiValidator();
  }
  /**
   * Выполняет HTTP GET запрос к API
   */
  async apiGet(endpoint, token, params = {}, headers) {
    if (!this.validator.isValidToken(token)) {
      throw new Error(t("provider.tokenRequired"));
    }
    const url = this.buildUrl(endpoint, params);
    try {
      const res = await (0, import_obsidian2.requestUrl)({
        url,
        method: "GET",
        headers: {
          Accept: "*/*",
          "X-API-KEY": token.trim(),
          ...headers
        }
      });
      return res.json;
    } catch (error) {
      throw this.errorHandler.handleApiError(error);
    }
  }
  /**
   * Строит URL с параметрами
   */
  buildUrl(endpoint, params) {
    const url = new URL(`${API_BASE_URL}${endpoint}`);
    for (const [key, value] of Object.entries(params)) {
      if (value !== void 0 && value !== null && value !== "") {
        url.searchParams.set(key, value.toString());
      }
    }
    return url.href;
  }
  /**
   * Поиск фильмов и сериалов по запросу
   */
  async searchByQuery(query, token) {
    if (!this.validator.isValidSearchQuery(query)) {
      throw new Error(t("provider.enterMovieTitle"));
    }
    const searchResults = await this.apiGet(
      "/movie/search",
      token,
      {
        query: query.trim(),
        limit: MAX_SEARCH_RESULTS
      }
    );
    if (!searchResults.docs || searchResults.docs.length === 0) {
      throw new Error(
        tWithParams("provider.nothingFound", { query }) + " " + t("provider.tryChangeQuery")
      );
    }
    return searchResults.docs;
  }
  /**
   * Получает детальную информацию о фильме/сериале
   */
  async getMovieById(id, token) {
    if (!this.validator.isValidMovieId(id)) {
      throw new Error(t("provider.invalidMovieId"));
    }
    if (!this.validator.isValidToken(token)) {
      throw new Error(t("provider.tokenRequiredForMovie"));
    }
    const movieData = await this.apiGet(
      `/movie/${id}`,
      token
    );
    if (!movieData) {
      throw new Error(t("provider.movieInfoError"));
    }
    const movieShow = this.dataFormatter.createMovieShowFrom(movieData);
    return movieShow;
  }
  /**
   * Проверяет валидность API токена
   */
  async validateToken(token) {
    if (!this.validator.isValidToken(token)) {
      return false;
    }
    try {
      await this.apiGet("/movie", token, {
        page: 1,
        limit: 1
      });
      return true;
    } catch (e) {
      return false;
    }
  }
};
var provider = new KinopoiskProvider();

// Views/search_modal.ts
var SearchModal = class extends import_obsidian3.Modal {
  constructor(plugin, callback) {
    super(plugin.app);
    this.callback = callback;
    this.isBusy = false;
    this.query = "";
    this.token = "";
    /**
     * Обработчик нажатия Enter для запуска поиска
     */
    this.submitEnterCallback = (event) => {
      if (event.key === "Enter" && !event.isComposing) {
        this.search();
      }
    };
    this.token = plugin.settings.apiToken;
    this.kinopoiskProvider = new KinopoiskProvider();
  }
  /**
   * Управляет состоянием загрузки UI
   */
  setBusy(busy) {
    var _a, _b, _c;
    this.isBusy = busy;
    (_a = this.okBtnRef) == null ? void 0 : _a.setDisabled(busy);
    (_b = this.okBtnRef) == null ? void 0 : _b.setButtonText(
      busy ? t("modals.searching") : t("modals.searchButton")
    );
    (_c = this.inputRef) == null ? void 0 : _c.setDisabled(busy);
  }
  /**
   * Валидирует входные данные перед поиском
   */
  validateInput() {
    var _a, _b;
    if (!((_a = this.query) == null ? void 0 : _a.trim())) {
      new import_obsidian3.Notice(t("modals.enterMovieName"));
      return false;
    }
    if (!((_b = this.token) == null ? void 0 : _b.trim())) {
      new import_obsidian3.Notice(t("modals.needApiToken"));
      return false;
    }
    if (this.isBusy) {
      return false;
    }
    return true;
  }
  /**
   * Обрабатывает ошибки поиска
   */
  handleSearchError(error) {
    const errorMessage = error instanceof Error ? error.message : t("modals.errorUnexpected");
    new import_obsidian3.Notice(errorMessage);
    this.callback(error);
  }
  /**
   * Выполняет поиск через API Кинопоиска
   */
  async search() {
    if (!this.validateInput()) {
      return;
    }
    try {
      this.setBusy(true);
      const searchResults = await this.kinopoiskProvider.searchByQuery(
        this.query.trim(),
        this.token
      );
      this.callback(null, searchResults);
      this.close();
    } catch (error) {
      this.handleSearchError(error);
    } finally {
      this.setBusy(false);
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: t("modals.searchTitle") });
    contentEl.createDiv(
      { cls: "kinopoisk-plugin__search-modal--input" },
      (settingItem) => {
        this.inputRef = new import_obsidian3.TextComponent(settingItem).setValue(this.query).setPlaceholder(t("modals.searchPlaceholder")).onChange((value) => this.query = value);
        this.inputRef.inputEl.addEventListener(
          "keydown",
          this.submitEnterCallback
        );
      }
    );
    new import_obsidian3.Setting(contentEl).addButton((btn) => {
      return this.okBtnRef = btn.setButtonText(t("modals.searchButton")).setCta().onClick(() => {
        this.search();
      });
    });
  }
  onClose() {
    var _a;
    if ((_a = this.inputRef) == null ? void 0 : _a.inputEl) {
      this.inputRef.inputEl.removeEventListener(
        "keydown",
        this.submitEnterCallback
      );
    }
    this.contentEl.empty();
  }
};

// Views/suggest_modal.ts
var import_obsidian5 = require("obsidian");

// Utils/imageUtils.ts
var import_obsidian4 = require("obsidian");
var DOWNLOAD_CONFIG = {
  timeout: 1e4,
  // 10 секунд таймаут
  maxRetries: 2,
  // максимум 2 попытки
  retryDelay: 1e3
  // задержка между попытками в мс
};
var SUPPORTED_EXTENSIONS = [
  "jpg",
  "jpeg",
  "png",
  "gif",
  "webp",
  "svg",
  "bmp"
];
var MIME_TO_EXTENSION_MAP = {
  "image/jpeg": "jpg",
  "image/jpg": "jpg",
  "image/png": "png",
  "image/gif": "gif",
  "image/webp": "webp",
  "image/svg+xml": "svg",
  "image/bmp": "bmp"
};
function isValidImageUrl(url) {
  if (!url || url.trim() === "") return false;
  try {
    new URL(url);
    return url.startsWith("http://") || url.startsWith("https://");
  } catch (e) {
    return false;
  }
}
function getImageExtension(url, mimeType) {
  var _a;
  if (mimeType && MIME_TO_EXTENSION_MAP[mimeType]) {
    return MIME_TO_EXTENSION_MAP[mimeType];
  }
  const urlExtension = (_a = url.split(".").pop()) == null ? void 0 : _a.toLowerCase();
  if (urlExtension && SUPPORTED_EXTENSIONS.includes(urlExtension)) {
    return urlExtension;
  }
  return "jpg";
}
function createImageFileName(movieShow, imageType, extension) {
  const baseName = `${movieShow.nameForFile}_${movieShow.year}_${imageType}`;
  const cleanedBaseName = replaceIllegalFileNameCharactersInString(baseName);
  return `${cleanedBaseName}.${extension}`;
}
function isNetworkError(error) {
  if (!error || typeof error !== "object" || typeof error.message !== "string") {
    return false;
  }
  const networkErrors = [
    "ERR_CONNECTION_TIMED_OUT",
    "ERR_NETWORK_CHANGED",
    "ERR_INTERNET_DISCONNECTED",
    "ERR_NAME_NOT_RESOLVED",
    "ERR_CONNECTION_REFUSED",
    "ERR_CONNECTION_RESET",
    "ERR_BLOCKED_BY_CLIENT"
  ];
  return networkErrors.some(
    (errorCode) => error.message.includes(errorCode)
  );
}
function withTimeout(promise, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(
        new Error(tWithParams("images.timeout", { timeout: timeoutMs }))
      );
    }, timeoutMs);
  });
  return Promise.race([promise, timeoutPromise]);
}
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function downloadImage(url) {
  if (!isValidImageUrl(url)) {
    throw new Error(tWithParams("images.invalidUrl", { url }));
  }
  let lastError = new Error(
    tWithParams("images.downloadFailed", { url })
  );
  for (let attempt = 1; attempt <= DOWNLOAD_CONFIG.maxRetries; attempt++) {
    try {
      const downloadPromise = (0, import_obsidian4.requestUrl)({
        url,
        method: "GET"
      });
      const response = await withTimeout(
        downloadPromise,
        DOWNLOAD_CONFIG.timeout
      );
      if (response.status !== 200) {
        if (response.status === 404) {
          throw new Error(
            tWithParams("images.imageNotFound", { url })
          );
        } else if (response.status === 403) {
          throw new Error(
            tWithParams("images.accessForbidden", { url })
          );
        } else if (response.status >= 500) {
          throw new Error(
            tWithParams("images.serverError", {
              status: response.status,
              url
            })
          );
        } else {
          throw new Error(
            tWithParams("images.httpError", {
              status: response.status,
              url
            })
          );
        }
      }
      return {
        data: response.arrayBuffer,
        mimeType: response.headers["content-type"]
      };
    } catch (error) {
      lastError = error;
      console.warn(
        `Failed to download image (attempt ${attempt}/${DOWNLOAD_CONFIG.maxRetries}): ${url}`,
        error
      );
      if (attempt === DOWNLOAD_CONFIG.maxRetries || !isNetworkError(error)) {
        break;
      }
      if (attempt < DOWNLOAD_CONFIG.maxRetries) {
        await delay(DOWNLOAD_CONFIG.retryDelay);
      }
    }
  }
  console.error(
    `Failed to download image after ${DOWNLOAD_CONFIG.maxRetries} attempts: ${url}`,
    lastError
  );
  throw lastError;
}
async function saveImageToVault(app, imageData, folderPath, fileName) {
  const { vault } = app;
  const normalizedFolderPath = (0, import_obsidian4.normalizePath)(folderPath);
  if (!vault.getAbstractFileByPath(normalizedFolderPath)) {
    await vault.createFolder(normalizedFolderPath);
  }
  const fullPath = (0, import_obsidian4.normalizePath)(`${folderPath}/${fileName}`);
  let finalPath = fullPath;
  let counter = 1;
  while (vault.getAbstractFileByPath(finalPath)) {
    const pathParts = fullPath.split(".");
    const extension = pathParts.pop();
    const basePath = pathParts.join(".");
    finalPath = `${basePath}_${counter}.${extension}`;
    counter++;
  }
  await vault.createBinary(finalPath, imageData);
  return finalPath;
}
async function downloadAndSaveImage(app, url, movieShow, imageType, folderPath) {
  try {
    if (!isValidImageUrl(url)) {
      return url;
    }
    const { data, mimeType } = await downloadImage(url);
    const extension = getImageExtension(url, mimeType);
    const fileName = createImageFileName(movieShow, imageType, extension);
    const localPath = await saveImageToVault(
      app,
      data,
      folderPath,
      fileName
    );
    return localPath;
  } catch (error) {
    console.error(`Failed to download and save image: ${url}`, error);
    throw error;
  }
}
function createImageLink(imagePath) {
  if (!imagePath || imagePath.trim() === "") return [];
  if (!imagePath.startsWith("http")) {
    const fileName = imagePath.split("/").pop() || imagePath;
    return [`![[${fileName}]]`];
  }
  return [`![](${imagePath})`];
}
function countImagesToDownload(movieShow, settings) {
  let count = 0;
  if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0] && isValidImageUrl(movieShow.posterUrl[0])) {
    count++;
  }
  if (settings.saveCoverImage && movieShow.coverUrl.length > 0 && movieShow.coverUrl[0] && isValidImageUrl(movieShow.coverUrl[0])) {
    count++;
  }
  if (settings.saveLogoImage && movieShow.logoUrl.length > 0 && movieShow.logoUrl[0] && isValidImageUrl(movieShow.logoUrl[0])) {
    count++;
  }
  return count;
}
function getImageTypeDisplayName(imageType) {
  return t(`images.${imageType}`);
}
async function processImages(app, movieShow, settings, progressCallback) {
  if (!settings.saveImagesLocally) {
    return movieShow;
  }
  const updatedMovieShow = { ...movieShow };
  const totalImages = countImagesToDownload(movieShow, settings);
  let processedImages = 0;
  let successfulDownloads = 0;
  let failedDownloads = 0;
  if (totalImages === 0) {
    progressCallback == null ? void 0 : progressCallback(0, 0, t("images.noImagesToDownload"));
    return movieShow;
  }
  try {
    if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0]) {
      const posterUrl = movieShow.posterUrl[0];
      if (isValidImageUrl(posterUrl)) {
        const imageTypeName = getImageTypeDisplayName("poster");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            posterUrl,
            movieShow,
            "poster",
            settings.imagesFolder
          );
          updatedMovieShow.posterImageLink = createImageLink(localPath);
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download poster image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.posterUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.poster")}`
            );
          }
          updatedMovieShow.posterImageLink = createImageLink(posterUrl);
        }
      } else {
        updatedMovieShow.posterImageLink = createImageLink(posterUrl);
      }
    }
    if (settings.saveCoverImage && movieShow.coverUrl.length > 0 && movieShow.coverUrl[0]) {
      const coverUrl = movieShow.coverUrl[0];
      if (isValidImageUrl(coverUrl)) {
        const imageTypeName = getImageTypeDisplayName("cover");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            coverUrl,
            movieShow,
            "cover",
            settings.imagesFolder
          );
          updatedMovieShow.coverImageLink = createImageLink(localPath);
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download cover image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.coverUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.cover")}`
            );
          }
          updatedMovieShow.coverImageLink = createImageLink(coverUrl);
        }
      } else {
        updatedMovieShow.coverImageLink = createImageLink(coverUrl);
      }
    }
    if (settings.saveLogoImage && movieShow.logoUrl.length > 0 && movieShow.logoUrl[0]) {
      const logoUrl = movieShow.logoUrl[0];
      if (isValidImageUrl(logoUrl)) {
        const imageTypeName = getImageTypeDisplayName("logo");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            logoUrl,
            movieShow,
            "logo",
            settings.imagesFolder
          );
          updatedMovieShow.logoImageLink = createImageLink(localPath);
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download logo image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.logoUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.logo")}`
            );
          }
          updatedMovieShow.logoImageLink = createImageLink(logoUrl);
        }
      } else {
        updatedMovieShow.logoImageLink = createImageLink(logoUrl);
      }
    }
    if (progressCallback) {
      if (failedDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          tWithParams("images.completedWithErrors", {
            successful: successfulDownloads,
            failed: failedDownloads
          })
        );
      } else if (successfulDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAllDownloaded")
        );
      } else {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAlreadyLocal")
        );
      }
    }
    if (failedDownloads > 0) {
      if (successfulDownloads > 0) {
        new import_obsidian4.Notice(
          tWithParams("images.downloadedWithErrors", {
            successful: successfulDownloads,
            total: totalImages
          })
        );
      } else {
        new import_obsidian4.Notice(t("images.imagesUnavailable"));
      }
    }
  } catch (error) {
    console.error("Error processing images:", error);
    progressCallback == null ? void 0 : progressCallback(
      processedImages,
      totalImages,
      t("images.processingError")
    );
    new import_obsidian4.Notice(t("images.processingError"));
  }
  return updatedMovieShow;
}

// Views/suggest_modal.ts
var ItemsSuggestModal = class extends import_obsidian5.SuggestModal {
  constructor(plugin, suggestion, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.suggestion = suggestion;
    this.onChoose = onChoose;
    this.token = "";
    this.token = plugin.settings.apiToken;
    this.kinopoiskProvider = new KinopoiskProvider();
  }
  /**
   * Фильтрует список предложений по поисковому запросу
   */
  getSuggestions(query) {
    return this.suggestion.filter((item) => {
      const searchQuery = query == null ? void 0 : query.toLowerCase();
      return item.name.toLowerCase().includes(searchQuery) || item.alternativeName.toLowerCase().includes(searchQuery);
    });
  }
  /**
   * Проверяет, является ли URL валидным для изображения
   */
  isValidImageUrl(url) {
    if (!url || url.trim() === "") return false;
    try {
      new URL(url);
      return url.startsWith("http://") || url.startsWith("https://");
    } catch (e) {
      return false;
    }
  }
  /**
   * Создает элемент изображения постера или заглушку
   */
  createPosterElement(item, container) {
    var _a;
    const posterUrl = (_a = item.poster) == null ? void 0 : _a.url;
    if (this.isValidImageUrl(posterUrl)) {
      const imgElement = container.createEl("img", {
        cls: "kinopoisk-plugin__suggest-poster"
      });
      imgElement.src = posterUrl;
      imgElement.addEventListener("error", () => {
        const placeholder = container.createEl("div", {
          text: t("modals.posterPlaceholderEmoji"),
          cls: "kinopoisk-plugin__suggest-poster-placeholder"
        });
        placeholder.title = t("modals.posterTooltipGeoblock");
        imgElement.replaceWith(placeholder);
      });
      return imgElement;
    } else {
      const placeholder = container.createEl("div", {
        text: t("modals.posterPlaceholderEmoji"),
        cls: "kinopoisk-plugin__suggest-poster-placeholder"
      });
      const reason = !posterUrl ? t("modals.posterTooltipMissing") : posterUrl.trim() === "" ? t("modals.posterTooltipEmptyLink") : t("modals.posterTooltipInvalidLink");
      placeholder.title = reason;
      return placeholder;
    }
  }
  /**
   * Отрисовывает элемент списка с постером и информацией о фильме/сериале
   */
  renderSuggestion(item, el) {
    const title = item.name;
    const subtitle = `${item.year}, ${item.alternativeName} (${item.type})`;
    const container = el.createEl("div", {
      cls: "kinopoisk-plugin__suggest-item"
    });
    this.createPosterElement(item, container);
    const textInfo = container.createEl("div", {
      cls: "kinopoisk-plugin__suggest-text-info"
    });
    textInfo.appendChild(el.createEl("div", { text: title }));
    textInfo.appendChild(el.createEl("small", { text: subtitle }));
  }
  /**
   * Обрабатывает выбор элемента из списка
   */
  onChooseSuggestion(item) {
    this.getItemDetails(item);
  }
  /**
   * Управляет отображением уведомлений о загрузке
   */
  updateStatus(message, persistent = true) {
    this.hideLoadingNotice();
    this.loadingNotice = new import_obsidian5.Notice(message, persistent ? 0 : 3e3);
  }
  /**
   * Скрывает уведомление о загрузке, если оно существует
   */
  hideLoadingNotice() {
    if (this.loadingNotice) {
      this.loadingNotice.hide();
      this.loadingNotice = void 0;
    }
  }
  /**
   * Обновляет текст существующего уведомления о загрузке
   */
  updateLoadingNotice(message) {
    if (this.loadingNotice) {
      const noticeEl = this.loadingNotice.noticeEl;
      if (noticeEl) {
        noticeEl.textContent = message;
      }
    } else {
      this.updateStatus(message);
    }
  }
  /**
   * Создает прогресс-бар в виде текста с процентами
   */
  createProgressText(current, total, task) {
    if (total === 0) return task;
    const percentage = Math.round(current / total * 100);
    const progressBar = this.createProgressBar(current, total);
    return `${task}
${progressBar} ${current}/${total} (${percentage}%)`;
  }
  /**
   * Создает визуальный прогресс-бар из символов
   */
  createProgressBar(current, total, length = 20) {
    if (total === 0) return "";
    const filled = Math.round(current / total * length);
    const empty = length - filled;
    return "\u2588".repeat(filled) + "\u2591".repeat(empty);
  }
  /**
   * Валидирует входные данные
   */
  validateInput(item) {
    var _a;
    if (!(item == null ? void 0 : item.id) || item.id <= 0) {
      new import_obsidian5.Notice(t("modals.errorMovieData"));
      this.onChoose(new Error(t("modals.errorMovieData")));
      return false;
    }
    if (!((_a = this.token) == null ? void 0 : _a.trim())) {
      new import_obsidian5.Notice(t("modals.needApiToken"));
      this.onChoose(new Error(t("modals.needApiToken")));
      return false;
    }
    return true;
  }
  /**
   * Получает основную информацию о фильме через API
   */
  async fetchMovieData(itemId) {
    return await this.kinopoiskProvider.getMovieById(itemId, this.token);
  }
  /**
   * Обрабатывает изображения фильма с прогресс-баром
   */
  async processMovieImages(movieShow) {
    this.updateLoadingNotice(t("modals.preparingImages"));
    let imageProcessingCompleted = false;
    const progressCallback = (current, total, currentTask) => {
      const progressText = this.createProgressText(
        current,
        total,
        currentTask
      );
      this.updateLoadingNotice(progressText);
      if (current === total) {
        imageProcessingCompleted = true;
      }
    };
    const processedMovieShow = await processImages(
      this.plugin.app,
      movieShow,
      this.plugin.settings,
      progressCallback
    );
    if (imageProcessingCompleted) {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
    }
    return processedMovieShow;
  }
  /**
   * Обрабатывает успешное получение данных фильма
   */
  handleSuccess(movieShow, hadImageProcessing = false) {
    this.hideLoadingNotice();
    if (!hadImageProcessing) {
      new import_obsidian5.Notice(t("modals.movieInfoLoaded"));
    } else {
    }
    this.onChoose(null, movieShow);
  }
  /**
   * Обрабатывает ошибки получения данных фильма
   */
  handleError(error) {
    this.hideLoadingNotice();
    const errorMessage = error instanceof Error ? error.message : t("modals.errorGettingDetails");
    new import_obsidian5.Notice(errorMessage);
    console.error("Error getting movie details:", error);
    this.onChoose(error);
  }
  /**
   * Получает детальную информацию о выбранном фильме/сериале через API
   * с поддержкой локального сохранения изображений и прогресс-бара
   */
  async getItemDetails(item) {
    if (!this.validateInput(item)) {
      return;
    }
    try {
      this.updateStatus(t("modals.loadingMovieInfo"));
      const movieShow = await this.fetchMovieData(item.id);
      if (!this.plugin.settings.saveImagesLocally) {
        this.handleSuccess(movieShow, false);
        return;
      }
      const processedMovieShow = await this.processMovieImages(movieShow);
      this.handleSuccess(processedMovieShow, true);
    } catch (error) {
      this.handleError(error);
    }
  }
  /**
   * Переопределяем метод закрытия для очистки уведомлений
   */
  onClose() {
    this.hideLoadingNotice();
    super.onClose();
  }
};

// Settings/settings.ts
var import_obsidian8 = require("obsidian");

// Settings/Suggesters/FolderSuggester.ts
var import_obsidian6 = require("obsidian");
var FolderSuggest = class extends import_obsidian6.AbstractInputSuggest {
  constructor(app, textInputEl, onSelectFolder) {
    super(app, textInputEl);
    this.onSelectFolder = onSelectFolder;
  }
  /**
   * Получает список папок, соответствующих введенному тексту
   */
  getSuggestions(inputStr) {
    if (!inputStr) {
      return [];
    }
    try {
      const abstractFiles = this.app.vault.getAllLoadedFiles();
      const folders = [];
      const lowerCaseInputStr = inputStr.toLowerCase();
      abstractFiles.forEach((folder) => {
        if (folder instanceof import_obsidian6.TFolder && folder.path.toLowerCase().includes(lowerCaseInputStr)) {
          folders.push(folder);
        }
      });
      return folders.slice(0, 20);
    } catch (error) {
      console.error(t("suggesters.folderListError"), error);
      return [];
    }
  }
  /**
   * Отображает предложение папки в выпадающем списке
   */
  renderSuggestion(folder, el) {
    if (folder && el) {
      el.setText(folder.path);
    }
  }
  /**
   * Обрабатывает выбор папки пользователем
   */
  selectSuggestion(folder) {
    if (folder && folder.path) {
      this.setValue(folder.path);
      this.onSelectFolder(folder.path);
      this.close();
    }
  }
};

// Settings/Suggesters/FileSuggester.ts
var import_obsidian7 = require("obsidian");
var FileSuggest = class extends import_obsidian7.AbstractInputSuggest {
  constructor(app, textInputEl, onSelectFile) {
    super(app, textInputEl);
    this.onSelectFile = onSelectFile;
  }
  /**
   * Получает список файлов, соответствующих введенному тексту
   * Фильтрует только .md файлы
   */
  getSuggestions(inputStr) {
    if (!inputStr) {
      return [];
    }
    try {
      const abstractFiles = this.app.vault.getAllLoadedFiles();
      const files = [];
      const lowerCaseInputStr = inputStr.toLowerCase();
      abstractFiles.forEach((file) => {
        if (file instanceof import_obsidian7.TFile && file.extension === "md" && file.path.toLowerCase().includes(lowerCaseInputStr)) {
          files.push(file);
        }
      });
      return files.slice(0, 20);
    } catch (error) {
      console.error(t("suggesters.fileListError"), error);
      return [];
    }
  }
  /**
   * Отображает предложение в выпадающем списке
   */
  renderSuggestion(file, el) {
    if (file && el) {
      el.setText(file.path);
    }
  }
  /**
   * Обрабатывает выбор файла пользователем
   */
  selectSuggestion(file) {
    if (file && file.path) {
      this.setValue(file.path);
      this.onSelectFile(file.path);
      this.close();
    }
  }
};

// Settings/settings.ts
var docUrl = "https://github.com/2PleXXX/obsidian-kinopoisk-search-plus-plugin";
var apiSite = "https://kinopoisk.dev/";
var DEFAULT_SETTINGS = {
  language: "en",
  apiToken: "",
  apiTokenValid: false,
  movieFileNameFormat: "",
  movieFolder: "",
  movieTemplateFile: "",
  seriesFileNameFormat: "",
  seriesFolder: "",
  seriesTemplateFile: "",
  // Значения по умолчанию для изображений
  imagesFolder: "attachments/kinopoisk",
  saveImagesLocally: false,
  savePosterImage: true,
  saveCoverImage: false,
  saveLogoImage: false
};
var ObsidianKinopoiskSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.validationTimeout = null;
    this.kinopoiskProvider = new KinopoiskProvider();
    setLanguage(this.plugin.settings.language);
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Очистка ресурсов при закрытии настроек
   */
  onClose() {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }
  }
  /**
   * Обновляет визуальный индикатор валидности токена
   */
  updateTokenValidationIndicator(inputElement, isValid) {
    if (!inputElement) return;
    inputElement.removeClass(
      "kinopoisk-plugin__token-valid",
      "kinopoisk-plugin__token-invalid",
      "kinopoisk-plugin__token-checking"
    );
    if (this.plugin.settings.apiToken.trim() !== "") {
      if (isValid === null) {
        inputElement.addClass("kinopoisk-plugin__token-checking");
      } else if (isValid) {
        inputElement.addClass("kinopoisk-plugin__token-valid");
      } else {
        inputElement.addClass("kinopoisk-plugin__token-invalid");
      }
    }
  }
  /**
   * Валидирует токен с задержкой
   */
  async validateTokenWithDelay(token, inputElement) {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
    }
    this.updateTokenValidationIndicator(inputElement, null);
    this.validationTimeout = setTimeout(async () => {
      try {
        const isValid = await this.kinopoiskProvider.validateToken(
          token
        );
        this.plugin.settings.apiTokenValid = isValid;
        await this.plugin.saveSettings();
        this.updateTokenValidationIndicator(inputElement, isValid);
      } catch (error) {
        console.error("Token validation error:", error);
        this.plugin.settings.apiTokenValid = false;
        await this.plugin.saveSettings();
        this.updateTokenValidationIndicator(inputElement, false);
      }
    }, 1500);
  }
  /**
   * Создает настройку для выбора папки
   */
  createFolderSetting(containerEl, name, desc, placeholder, currentValue, onValueChange) {
    new import_obsidian8.Setting(containerEl).setName(name).setDesc(desc).addSearch((cb) => {
      try {
        new FolderSuggest(this.app, cb.inputEl, onValueChange);
      } catch (error) {
        console.error("Error creating FolderSuggest:", error);
      }
      cb.setPlaceholder(placeholder).setValue(currentValue).onChange(onValueChange);
    });
  }
  /**
   * Создает настройку для выбора файла шаблона
   */
  createTemplateSetting(containerEl, name, desc, placeholder, currentValue, onValueChange) {
    new import_obsidian8.Setting(containerEl).setName(name).setDesc(desc).addSearch((cb) => {
      try {
        new FileSuggest(this.app, cb.inputEl, onValueChange);
      } catch (error) {
        console.error("Error creating FileSuggest:", error);
      }
      cb.setPlaceholder(placeholder).setValue(currentValue).onChange(onValueChange);
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.classList.add("obsidian-kinopoisk-plugin__settings");
    new import_obsidian8.Setting(containerEl).setName(t("settings.languageHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.language")).setDesc(t("settings.languageDesc")).addDropdown((dropdown) => {
      const languages = getSupportedLanguages();
      languages.forEach((lang) => {
        dropdown.addOption(lang.code, lang.name);
      });
      dropdown.setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        setLanguage(value);
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const apiKeyDesc = document.createDocumentFragment();
    apiKeyDesc.createDiv({
      text: t("settings.apiTokenDesc")
    });
    apiKeyDesc.createEl("a", {
      text: t("settings.getApiToken"),
      href: apiSite
    });
    let tokenInputElement;
    new import_obsidian8.Setting(containerEl).setName(t("settings.apiToken")).setDesc(apiKeyDesc).addText((text) => {
      const textComponent = text.setPlaceholder(t("settings.enterToken")).setValue(this.plugin.settings.apiToken).onChange(async (value) => {
        this.plugin.settings.apiToken = value.trim();
        this.plugin.settings.apiTokenValid = false;
        await this.plugin.saveSettings();
        if (value.trim() !== "") {
          await this.validateTokenWithDelay(
            value.trim(),
            textComponent.inputEl
          );
        } else {
          if (this.validationTimeout) {
            clearTimeout(this.validationTimeout);
            this.validationTimeout = null;
          }
          this.updateTokenValidationIndicator(
            textComponent.inputEl,
            false
          );
        }
      });
      tokenInputElement = textComponent.inputEl;
      if (this.plugin.settings.apiToken.trim() !== "") {
        this.updateTokenValidationIndicator(
          textComponent.inputEl,
          this.plugin.settings.apiTokenValid
        );
      }
      return textComponent;
    }).addButton(
      (button) => button.setButtonText(t("settings.checkToken")).setCta().onClick(async () => {
        const token = this.plugin.settings.apiToken.trim();
        if (!token) {
          new import_obsidian8.Notice(t("settings.enterToken"));
          return;
        }
        button.setDisabled(true);
        button.setButtonText(t("settings.checking"));
        try {
          new import_obsidian8.Notice(t("settings.checking"));
          const isValid = await this.kinopoiskProvider.validateToken(
            token
          );
          this.plugin.settings.apiTokenValid = isValid;
          await this.plugin.saveSettings();
          this.updateTokenValidationIndicator(
            tokenInputElement,
            isValid
          );
          new import_obsidian8.Notice(
            isValid ? t("settings.tokenValid") : t("settings.tokenInvalid")
          );
        } catch (error) {
          console.error(
            "Manual token validation error:",
            error
          );
          this.plugin.settings.apiTokenValid = false;
          await this.plugin.saveSettings();
          this.updateTokenValidationIndicator(
            tokenInputElement,
            false
          );
          new import_obsidian8.Notice(t("settings.tokenError"));
        } finally {
          button.setDisabled(false);
          button.setButtonText(t("settings.checkToken"));
        }
      })
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.imagesHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.saveImagesLocally")).setDesc(t("settings.saveImagesLocallyDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveImagesLocally).onChange(async (value) => {
        this.plugin.settings.saveImagesLocally = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.saveImagesLocally) {
      this.createFolderSetting(
        containerEl,
        t("settings.imagesFolder"),
        t("settings.imagesFolderDesc"),
        t("settings.imagesFolderPlaceholder"),
        this.plugin.settings.imagesFolder,
        async (folder) => {
          this.plugin.settings.imagesFolder = folder;
          await this.plugin.saveSettings();
        }
      );
      new import_obsidian8.Setting(containerEl).setName(t("settings.savePosterImage")).setDesc(t("settings.savePosterImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.savePosterImage).onChange(async (value) => {
          this.plugin.settings.savePosterImage = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian8.Setting(containerEl).setName(t("settings.saveCoverImage")).setDesc(t("settings.saveCoverImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.saveCoverImage).onChange(async (value) => {
          this.plugin.settings.saveCoverImage = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian8.Setting(containerEl).setName(t("settings.saveLogoImage")).setDesc(t("settings.saveLogoImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.saveLogoImage).onChange(async (value) => {
          this.plugin.settings.saveLogoImage = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian8.Setting(containerEl).setName(t("settings.moviesHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.movieFileName")).setDesc(t("settings.movieFileNameDesc")).addText(
      (text) => text.setPlaceholder(t("settings.movieFileNamePlaceholder")).setValue(this.plugin.settings.movieFileNameFormat).onChange(async (value) => {
        this.plugin.settings.movieFileNameFormat = value;
        await this.plugin.saveSettings();
      })
    );
    this.createFolderSetting(
      containerEl,
      t("settings.movieFileLocation"),
      t("settings.movieFileLocationDesc"),
      t("settings.movieFileLocationPlaceholder"),
      this.plugin.settings.movieFolder,
      async (folder) => {
        this.plugin.settings.movieFolder = folder;
        await this.plugin.saveSettings();
      }
    );
    const movieTemplateFileDesc = document.createDocumentFragment();
    movieTemplateFileDesc.createDiv({
      text: t("settings.movieTemplateFileDesc")
    });
    movieTemplateFileDesc.createEl("a", {
      text: t("settings.exampleTemplate"),
      href: `${docUrl}#example-template`
    });
    this.createTemplateSetting(
      containerEl,
      t("settings.movieTemplateFile"),
      movieTemplateFileDesc,
      t("settings.movieTemplateFilePlaceholder"),
      this.plugin.settings.movieTemplateFile,
      async (file) => {
        this.plugin.settings.movieTemplateFile = file;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.seriesHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.seriesFileName")).setDesc(t("settings.seriesFileNameDesc")).addText(
      (text) => text.setPlaceholder(t("settings.seriesFileNamePlaceholder")).setValue(this.plugin.settings.seriesFileNameFormat).onChange(async (value) => {
        this.plugin.settings.seriesFileNameFormat = value;
        await this.plugin.saveSettings();
      })
    );
    this.createFolderSetting(
      containerEl,
      t("settings.seriesFileLocation"),
      t("settings.seriesFileLocationDesc"),
      t("settings.seriesFileLocationPlaceholder"),
      this.plugin.settings.seriesFolder,
      async (folder) => {
        this.plugin.settings.seriesFolder = folder;
        await this.plugin.saveSettings();
      }
    );
    const seriesTemplateFileDesc = document.createDocumentFragment();
    seriesTemplateFileDesc.createDiv({
      text: t("settings.seriesTemplateFileDesc")
    });
    seriesTemplateFileDesc.createEl("a", {
      text: t("settings.exampleTemplate"),
      href: `${docUrl}#example-template`
    });
    this.createTemplateSetting(
      containerEl,
      t("settings.seriesTemplateFile"),
      seriesTemplateFileDesc,
      t("settings.seriesTemplateFilePlaceholder"),
      this.plugin.settings.seriesTemplateFile,
      async (file) => {
        this.plugin.settings.seriesTemplateFile = file;
        await this.plugin.saveSettings();
      }
    );
  }
};

// Utils/cursor_jumper.ts
var import_obsidian9 = require("obsidian");
var CursorJumper = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Перемещает курсор в начало активного документа
   * Используется после создания новой заметки для удобства редактирования
   */
  async jumpToNextCursorLocation() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
      if (!(activeView == null ? void 0 : activeView.file)) {
        return;
      }
      const editor = activeView.editor;
      if (!editor) {
        return;
      }
      editor.focus();
      editor.setCursor(0, 0);
    } catch (error) {
      console.error("Error moving cursor:", error);
    }
  }
};

// main.ts
var ObsidianKinopoiskPlugin = class extends import_obsidian10.Plugin {
  async onload() {
    await this.loadSettings();
    initializeLanguage(this.settings.language);
    this.addRibbonIcon("film", "Search in Kinopoisk", () => {
      this.createNewNote();
    });
    this.addCommand({
      id: "open-search-kinopoisk-modal",
      name: "Search",
      callback: () => {
        this.createNewNote();
      }
    });
    this.addSettingTab(new ObsidianKinopoiskSettingTab(this.app, this));
  }
  /**
   * Отображает уведомление с ошибкой пользователю
   */
  showNotice(error) {
    try {
      new import_obsidian10.Notice(error.message);
    } catch (e) {
    }
  }
  /**
   * Основной метод создания новой заметки:
   * - Выполняет поиск и выбор фильма/сериала
   * - Определяет шаблон и папку в зависимости от типа контента
   * - Создает папку если она не существует
   * - Создает файл с уникальным именем
   * - Заполняет шаблон данными и открывает для редактирования
   */
  async createNewNote() {
    try {
      const movieShow = await this.searchMovieShow();
      const {
        movieFileNameFormat,
        movieFolder,
        seriesFileNameFormat,
        seriesFolder
      } = this.settings;
      const renderedContents = await this.getRenderedContents(movieShow);
      const fileNameFormat = movieShow.isSeries ? seriesFileNameFormat : movieFileNameFormat;
      const folderPath = movieShow.isSeries ? seriesFolder : movieFolder;
      if (folderPath && !await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      const fileName = await makeFileName(
        this.app,
        movieShow,
        fileNameFormat,
        folderPath
      );
      const filePath = `${folderPath}/${fileName}`;
      const targetFile = await this.app.vault.create(
        filePath,
        renderedContents
      );
      const newLeaf = this.app.workspace.getLeaf(true);
      if (!newLeaf) {
        console.warn("No new leaf");
        return;
      }
      await newLeaf.openFile(targetFile, { state: { mode: "source" } });
      newLeaf.setEphemeralState({ rename: "all" });
      await new CursorJumper(this.app).jumpToNextCursorLocation();
    } catch (err) {
      console.warn(err);
      this.showNotice(err);
    }
  }
  /**
   * Координирует процесс поиска: сначала поиск, затем выбор из результатов
   */
  async searchMovieShow() {
    const searchedItems = await this.openSearchModal();
    return await this.openSuggestModal(searchedItems);
  }
  /**
   * Открывает модальное окно поиска и возвращает найденные элементы
   */
  async openSearchModal() {
    return new Promise((resolve, reject) => {
      return new SearchModal(this, (error, results) => {
        return error ? reject(error) : resolve(results != null ? results : []);
      }).open();
    });
  }
  /**
   * Открывает модальное окно выбора и возвращает детальную информацию о выбранном элементе
   */
  async openSuggestModal(items) {
    return new Promise((resolve, reject) => {
      return new ItemsSuggestModal(this, items, (error, selectedItem) => {
        return error ? reject(error) : resolve(selectedItem);
      }).open();
    });
  }
  /**
   * Загружает содержимое шаблона и заполняет его данными фильма/сериала
   */
  async getRenderedContents(movieShow) {
    const { movieTemplateFile, seriesTemplateFile } = this.settings;
    const templateFile = movieShow.isSeries ? seriesTemplateFile : movieTemplateFile;
    if (templateFile) {
      const templateContents = await getTemplateContents(
        this.app,
        templateFile
      );
      const replacedVariable = replaceVariableSyntax(
        movieShow,
        templateContents
      );
      return replacedVariable;
    }
    return "";
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
